import aperture;
import buffers.scene;
import buffers.sky;
import lib.common;
import lib.sampling.R2;
import lib.light.floodfill;

extern static const int DIMENSION;

RWStructuredBuffer<SceneBuffer> scene_writer;


[[shader("compute")]]
[numthreads(1,1,1)]
void beginScene() {
    if (TAA_Enabled) {
        scene_writer[0].taa_jitter = GetR2_2D(ap.timing.frameCounter) - 0.5;
        scene_writer[0].taa_jitter /= ap.game.screenSize;
    }
    
    scene_writer[0].SunLocalDir = normalize(mul(float3x3(ap.camera.viewInv), ap.celestial.sunPosition));
    scene_writer[0].MoonLocalDir = normalize(mul(float3x3(ap.camera.viewInv), ap.celestial.moonPosition));
    scene_writer[0].SkyLightLocalDir = normalize(mul(float3x3(ap.camera.viewInv), ap.celestial.position));

    for (int i = 0; i < SHADOW_CASCADE_COUNT; i++) {
        scene_writer[0].shadowViewMin[i] = mul3(ap.celestial.projectionInv[i], float3(-1.0, -1.0, 0.0)).xy;
        scene_writer[0].shadowViewMax[i] = mul3(ap.celestial.projectionInv[i], float3( 1.0,  1.0, 0.0)).xy;
    }

    if (DIMENSION != DIM_END) {
        float blend = smoothstep(0.0, 1.0, ap.world.rainStrength);
        lerp(skyClear, skyRain, blend, scene_writer[0].sky);
        //lerp(scene_writer[0].sky, skyThunder, ap.world.thunderStrength, scene_writer[0].sky);
    }

    scene_writer[0].FloodFillCenter = GetVoxelCenter(ap.camera.position);
}
