import aperture;
import lib.common;
import lib.material.pbr;
import lib.sampling.IGN;
import lib.shadow;

Sampler2D<float> solidDepthTex;

Sampler2D<half4> texAlbedoGB;
Sampler2D<uint2> texNormalGB;
Sampler2D<uint2> texMatLightGB;


struct FragmentOutput {
    float4 shadow : SV_Target0;
    float4 sss : SV_Target1;
};

[[shader("fragment")]]
FragmentOutput skyShadowSss(float2 pos : SV_Position) {
    FragmentOutput output;
    output.shadow = 1.0;
    output.sss = float4(0.0, 0.0, 0.0, 1.0);

    uint2 uv = uint2(pos);
    float depth = solidDepthTex[uv];
    
    if (depth < 1.0) {
        float2 texcoord = pos / ap.game.screenSize;
        if (TAA_Enabled) texcoord -= scene[0].taa_jitter;

        float3 clipPos = float3(texcoord, depth) * 2.0 - 1.0;
        float3 viewPos = project(ap.camera.projectionInv, clipPos);
        float3 localPos = mul3(ap.camera.viewInv, viewPos);
        float3 viewLocalDir = -normalize(localPos);

        half4 colorData = texAlbedoGB[uv];
        uint2 normalData = texNormalGB[uv];
        uint2 matLightData = texMatLightGB[uv];

        half4 specularData = unpackUnorm4x8ToHalf(matLightData.r);
        // float3 albedo = RgbToLinear(colorData.rgb);
        // float roughness = mat_roughness(specularData.r);
        // float f0_metal = mat_f0_metal(specularData.g);
        float sss = mat_sss(specularData.b);

        float3 geo_normal = normalize(unpackUnorm4x8ToFloat(normalData.r).xyz * 2.0 - 1.0);
        float3 tex_normal = normalize(unpackUnorm4x8ToFloat(normalData.g).xyz * 2.0 - 1.0);

        half4 lightData = unpackUnorm4x8ToHalf(matLightData.g);

        float dither;
        if (TAA_Enabled) {
            dither = InterleavedGradientNoiseTime(uv);
        }
        else {
            dither = InterleavedGradientNoise(uv);
        }

        // Shadows
        float viewDist = length(viewPos);
        float geo_NoLm = 1.0 - max(dot(geo_normal, scene[0].SkyLightLocalDir), 0.0);
        float normal_bias = geo_NoLm * (viewDist * 0.006 + 0.06);
        float offset_bias = viewDist * 0.002;

        float3 shadowLocalPos = geo_normal * normal_bias + localPos;
        float3 shadowViewPos = mul3(ap.celestial.view, shadowLocalPos);
        shadowViewPos.z += offset_bias;
        
        int cascade = GetShadowProjection(shadowViewPos, Shadow_MaxPcfSize);

        if (cascade >= 0) {
            float3 shadowPos = mul3(ap.celestial.projection[cascade], shadowViewPos) * 0.5 + 0.5;

            // output.shadow = SampleShadow_PCSS(shadowPos, cascade, dither);
            output.shadow.rgb = SampleShadowColor_PCSS(shadowPos, cascade, dither);
        }

        // SSS
        shadowViewPos = mul3(ap.celestial.view, localPos);
        
        float blockRadius = sss * SSS_BlockRadius;
        cascade = GetShadowProjection(shadowViewPos, blockRadius);

        if (cascade >= 0) {
            float3 shadowPos = mul3(ap.celestial.projection[cascade], shadowViewPos) * 0.5 + 0.5;

            float3 cascadeScale = GetShadowProjectionScale(cascade);

            float bias_scale = sss * SSS_MaxDist * cascadeScale.z;
            float2 pixelRadius = blockRadius * cascadeScale.xy;
            float2 coverage_dist = SSS_PCF(shadowPos, cascade, pixelRadius, bias_scale, sss, dither);

            float absorb_depth = 1.0 * (coverage_dist.y / cascadeScale.z) + 0.1;
            float3 sss_color = normalize(RgbToLinear(1.0 - colorData.rgb) + 0.02);
            float3 lit = coverage_dist.x * exp(-(absorb_depth * sss_color + EPSILON));

            float tex_NoLm = max(dot(tex_normal, scene[0].SkyLightLocalDir), 0.0);
            output.sss.rgb = sss * (1.0 - tex_NoLm) * lit;
        }
    }

    return output;
}
